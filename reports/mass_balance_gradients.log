Traceback (most recent call last):
  File "/usr/local/pyenv/versions/3.8.12/lib/python3.8/site-packages/jupyter_cache/executors/utils.py", line 51, in single_nb_execution
    executenb(
  File "/usr/local/pyenv/versions/3.8.12/lib/python3.8/site-packages/nbclient/client.py", line 1117, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "/usr/local/pyenv/versions/3.8.12/lib/python3.8/site-packages/nbclient/util.py", line 78, in wrapped
    return just_run(coro(*args, **kwargs))
  File "/usr/local/pyenv/versions/3.8.12/lib/python3.8/site-packages/nbclient/util.py", line 57, in just_run
    return loop.run_until_complete(coro)
  File "/usr/local/pyenv/versions/3.8.12/lib/python3.8/asyncio/base_events.py", line 616, in run_until_complete
    return future.result()
  File "/usr/local/pyenv/versions/3.8.12/lib/python3.8/site-packages/nbclient/client.py", line 558, in async_execute
    await self.async_execute_cell(
  File "/usr/local/pyenv/versions/3.8.12/lib/python3.8/site-packages/nbclient/client.py", line 862, in async_execute_cell
    self._check_raise_for_error(cell, exec_reply)
  File "/usr/local/pyenv/versions/3.8.12/lib/python3.8/site-packages/nbclient/client.py", line 765, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
# Save the response times in a list.
response_times = []
# Loop over the different gradients again.
for i, gradient in enumerate(gradients):
    # Years, incremental steps of 5.
    yrs = np.arange(0, models_pert[i].yr, 5)
    # Number of steps we'll take.
    nsteps = len(yrs)
    # Save the intermediate steps.
    lengths = np.zeros(nsteps)
    volumes = np.zeros(nsteps)
    years = np.zeros(nsteps)
    # Initialize the glacier model again.
    mb_model = LinearMassBalance(new_ELA, grad=gradient)
    model = FlowlineModel(models[i].fls[0], mb_model, y0=models[i].yr)
    # Then we loop over the years.
    for j, year in enumerate(yrs):
        # Run the model until year.
        model.run_until(year)
        # Save the states
        years[j] = model.yr
        lengths[j] = model.length_m
        volumes[j] = model.volume_km3
        
    # The final volume difference is then
    v2 = model.volume_km3
    # This is the e-folding volume difference.
    v2_diff = v2 - (model.volume_km3 - models[i].volume_km3) / np.e
    # We want to find the year where the volume is closest to the v2_diff.
    # Take the difference
    all_vol_diff = np.abs(volumes - vol_diff)
    # Search for the smallest difference and get the index
    index = np.argmin(all_vol_diff)
    # Retreive the year
    response_time = years[index] - models[i].yr
    # Save it
    response_times.append(response_time)
------------------

[0;31m---------------------------------------------------------------------------[0m
[0;31mNameError[0m                                 Traceback (most recent call last)
[0;32m/tmp/ipykernel_813/2643249588.py[0m in [0;36m<module>[0;34m[0m
[1;32m     29[0m     [0;31m# We want to find the year where the volume is closest to the v2_diff.[0m[0;34m[0m[0;34m[0m[0;34m[0m[0m
[1;32m     30[0m     [0;31m# Take the difference[0m[0;34m[0m[0;34m[0m[0;34m[0m[0m
[0;32m---> 31[0;31m     [0mall_vol_diff[0m [0;34m=[0m [0mnp[0m[0;34m.[0m[0mabs[0m[0;34m([0m[0mvolumes[0m [0;34m-[0m [0mvol_diff[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m     32[0m     [0;31m# Search for the smallest difference and get the index[0m[0;34m[0m[0;34m[0m[0;34m[0m[0m
[1;32m     33[0m     [0mindex[0m [0;34m=[0m [0mnp[0m[0;34m.[0m[0margmin[0m[0;34m([0m[0mall_vol_diff[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m

[0;31mNameError[0m: name 'vol_diff' is not defined
NameError: name 'vol_diff' is not defined

